# Type-Based Quality Rules
#
# These filter graphs apply to columns based on their data type.
# Each graph targets a specific type and defines the quality checks.

---
# DOUBLE type checks
graph_id: "type_double_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Double/Float Column Quality"
  description: "Quality rules for floating point columns"
  category: "quality"
  source: "system"
  tags: ["type-based", "double", "numeric"]
  applies_to:
    data_type: "DOUBLE"

output:
  type: "classification"
  categories:
    clean: "Float column passes all checks"
    flag: "Float column has potential issues"

dependencies:
  not_nan:
    level: 1
    type: "predicate"
    condition: "NOT isnan({column}) OR {column} IS NULL"
    on_false: "flag"
    reason: "Floating point columns should not contain NaN"
    severity: "medium"

  not_inf:
    level: 1
    type: "predicate"
    condition: "NOT isinf({column}) OR {column} IS NULL"
    on_false: "flag"
    reason: "Floating point columns should not contain infinity"
    severity: "medium"

  double_clean:
    level: 2
    type: "composite"
    logic: "not_nan AND not_inf"
    depends_on: ["not_nan", "not_inf"]
    output_step: true

---
# DATE type checks
graph_id: "type_date_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Date Column Quality"
  description: "Quality rules for date columns"
  category: "quality"
  source: "system"
  tags: ["type-based", "date", "temporal"]
  applies_to:
    data_type: "DATE"

output:
  type: "classification"
  categories:
    clean: "Date column passes all checks"
    quarantine: "Date column has invalid values"

dependencies:
  valid_date:
    level: 1
    type: "predicate"
    condition: "TRY_CAST({column} AS DATE) IS NOT NULL OR {column} IS NULL"
    on_false: "quarantine"
    reason: "Date values must be parseable"
    severity: "critical"

  date_clean:
    level: 2
    type: "composite"
    logic: "valid_date"
    depends_on: ["valid_date"]
    output_step: true

---
# TIMESTAMP type checks
graph_id: "type_timestamp_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Timestamp Column Quality"
  description: "Quality rules for timestamp columns"
  category: "quality"
  source: "system"
  tags: ["type-based", "timestamp", "temporal"]
  applies_to:
    data_type: "TIMESTAMP"

output:
  type: "classification"
  categories:
    clean: "Timestamp column passes all checks"
    quarantine: "Timestamp column has invalid values"

dependencies:
  valid_timestamp:
    level: 1
    type: "predicate"
    condition: "TRY_CAST({column} AS TIMESTAMP) IS NOT NULL OR {column} IS NULL"
    on_false: "quarantine"
    reason: "Timestamp values must be parseable"
    severity: "critical"

  timestamp_clean:
    level: 2
    type: "composite"
    logic: "valid_timestamp"
    depends_on: ["valid_timestamp"]
    output_step: true

---
# VARCHAR type checks
graph_id: "type_varchar_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "String Column Quality"
  description: "Quality rules for string columns"
  category: "quality"
  source: "system"
  tags: ["type-based", "varchar", "string"]
  applies_to:
    data_type: "VARCHAR"

parameters:
  - name: "max_length"
    param_type: "integer"
    default: 10000
    description: "Maximum allowed string length"

output:
  type: "classification"
  categories:
    clean: "String column passes all checks"
    flag: "String column has potential issues"

dependencies:
  reasonable_length:
    level: 1
    type: "predicate"
    condition: "LENGTH({column}) <= {max_length} OR {column} IS NULL"
    on_false: "flag"
    reason: "String values should not exceed reasonable length"
    severity: "low"

  varchar_clean:
    level: 2
    type: "composite"
    logic: "reasonable_length"
    depends_on: ["reasonable_length"]
    output_step: true
