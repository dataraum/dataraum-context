# Role-Based Quality Rules
#
# These filter graphs apply to columns based on their semantic role.
# Each graph targets a specific role and defines the quality checks.

---
# Key column checks
graph_id: "role_key_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Key Column Quality"
  description: "Quality rules for key columns (primary identifiers)"
  category: "quality"
  source: "system"
  tags: ["role-based", "key", "identity"]
  applies_to:
    semantic_role: "key"

output:
  type: "classification"
  categories:
    clean: "Key column passes all checks"
    quarantine: "Key column has quality issues"

dependencies:
  key_not_null:
    level: 1
    type: "predicate"
    condition: "{column} IS NOT NULL"
    on_false: "quarantine"
    reason: "Key columns must not contain null values"
    severity: "critical"

  key_unique:
    level: 1
    type: "predicate"
    condition: "COUNT(*) OVER () = COUNT(DISTINCT {column}) OVER ()"
    on_false: "quarantine"
    reason: "Key columns must contain unique values"
    severity: "critical"

  key_clean:
    level: 2
    type: "composite"
    logic: "key_not_null AND key_unique"
    depends_on: ["key_not_null", "key_unique"]
    output_step: true

---
# Timestamp column checks
graph_id: "role_timestamp_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Timestamp Column Quality"
  description: "Quality rules for timestamp columns"
  category: "quality"
  source: "system"
  tags: ["role-based", "timestamp", "temporal"]
  applies_to:
    semantic_role: "timestamp"

parameters:
  - name: "min_date"
    param_type: "date"
    default: "1970-01-01"
    description: "Minimum valid date"
  - name: "max_date"
    param_type: "date"
    default: "2100-01-01"
    description: "Maximum valid date"

output:
  type: "classification"
  categories:
    clean: "Timestamp passes all checks"
    flag: "Timestamp has potential issues"

dependencies:
  timestamp_not_null:
    level: 1
    type: "predicate"
    condition: "{column} IS NOT NULL"
    on_false: "flag"
    reason: "Timestamp columns should not contain nulls"
    severity: "high"

  timestamp_in_range:
    level: 1
    type: "predicate"
    condition: "{column} >= '{min_date}' AND {column} <= '{max_date}'"
    on_false: "flag"
    reason: "Timestamps should be within reasonable range"
    severity: "medium"

  timestamp_clean:
    level: 2
    type: "composite"
    logic: "timestamp_not_null AND timestamp_in_range"
    depends_on: ["timestamp_not_null", "timestamp_in_range"]
    output_step: true

---
# Measure column checks
graph_id: "role_measure_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Measure Column Quality"
  description: "Quality rules for measure/metric columns"
  category: "quality"
  source: "system"
  tags: ["role-based", "measure", "numeric"]
  applies_to:
    semantic_role: "measure"

output:
  type: "classification"
  categories:
    clean: "Measure column passes all checks"
    quarantine: "Measure column has quality issues"

dependencies:
  measure_numeric:
    level: 1
    type: "predicate"
    condition: "TRY_CAST({column} AS DOUBLE) IS NOT NULL OR {column} IS NULL"
    on_false: "quarantine"
    reason: "Measure columns must be numeric"
    severity: "critical"

  measure_clean:
    level: 2
    type: "composite"
    logic: "measure_numeric"
    depends_on: ["measure_numeric"]
    output_step: true

---
# Foreign key column checks
graph_id: "role_foreign_key_checks"
graph_type: "filter"
version: "1.0"

metadata:
  name: "Foreign Key Column Quality"
  description: "Quality rules for foreign key columns"
  category: "quality"
  source: "system"
  tags: ["role-based", "foreign_key", "referential"]
  applies_to:
    semantic_role: "foreign_key"

output:
  type: "classification"
  categories:
    clean: "Foreign key passes referential check"
    quarantine: "Foreign key has orphaned references"

dependencies:
  # Note: Referential integrity requires context about the target table
  # This is a placeholder - actual check requires schema mapping
  fk_not_null_or_valid:
    level: 1
    type: "predicate"
    condition: "{column} IS NULL OR {column} IN (SELECT {target_column} FROM {target_table})"
    on_false: "quarantine"
    reason: "Foreign keys must reference existing values"
    severity: "critical"

  fk_clean:
    level: 2
    type: "composite"
    logic: "fk_not_null_or_valid"
    depends_on: ["fk_not_null_or_valid"]
    output_step: true
